{"meta":{"title":"Perfree","subtitle":"学而时习之,不亦说乎","description":"云淡风轻","author":"Perfree","url":"http://www.perfree.top"},"pages":[{"title":"","date":"2018-06-04T05:04:29.438Z","updated":"2018-06-04T03:59:40.398Z","comments":false,"path":"categories/index.html","permalink":"http://www.perfree.top/categories/index.html","excerpt":"","text":""},{"title":"","date":"2018-06-04T05:04:34.251Z","updated":"2018-06-04T03:59:10.904Z","comments":false,"path":"tags/index.html","permalink":"http://www.perfree.top/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"第一次使用MyBatis","slug":"2018-06-11","date":"2018-06-11T08:22:18.000Z","updated":"2018-06-11T11:46:43.541Z","comments":true,"path":"2018/06/11/2018-06-11/","link":"","permalink":"http://www.perfree.top/2018/06/11/2018-06-11/","excerpt":"","text":"MyBatis是一款支持定制化SQL,存储过程以及高级映射的优秀的持久层框架。MyBatis 避免了几乎所有的 JDBC 代码和手工设置参数以及抽取结果集。MyBatis 使用简单的 XML 或注解来配置和映射基本体，将接口和 Java 的 POJOs(Plain Old Java Objects,普通的 Java对象)映射成数据库中的记录。官方文档 1.下载MyBatis官方下载地址这里使用的是mybatis-3.4.6.zip 2.导包将下载的压缩包解压,导入里边所有jar包(一共13个…),之后再导入所使用的数据库jar包就ok了,这里使用的是MySql数据库 3.全局配置web项目在Java Resources新建config资源目录,在该目录下新建MyBatis全局配置文件sqlMapConfig.xml(名称随意),它包含了数据源和事务管理器等设置和属性信息,基础环境配置:12345678910111213141516171819202122232425&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE configurationPUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"\"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt; &lt;environments default=\"development\"&gt; &lt;environment id=\"development\"&gt; &lt;transactionManager type=\"JDBC\"/&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;!-- 数据库连接配置 --&gt; &lt;property name=\"driver\" value=\"$&#123;driver&#125;\"/&gt; &lt;property name=\"url\" value=\"$&#123;url&#125;\"/&gt; &lt;property name=\"username\" value=\"$&#123;username&#125;\"/&gt; &lt;property name=\"password\" value=\"$&#123;password&#125;\"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;environment id=\"development2\"&gt; &lt;!--核心映射文件地址,示例如下(可使用相对路径或者绝对路径)--&gt; &lt;mapper resource=\"mapper/UserMapper.xml\"/&gt; &lt;!--绝对路径--&gt; &lt;mapper url=\"file:///var/sqlmaps/AuthorMapper.xml\"/&gt; ...... &lt;/environment&gt; &lt;/environments&gt; &lt;/configuration&gt; 3.1.MyBatis 事务管理类JDBC - 这个类型直接全部使用 JDBC 的提交和回滚功能。它依靠使用连接的数据源来管理事务的作用域。MANAGED - 这个类型什么不做 ， 它从不提交 、 回滚和关闭连接 。 而是让窗口来管理事务的全部生命周期 。（比如说 Spring 或者JAVAEE 服务器） 3.2.MyBatis 数据源类型UNPOOLED -这个数据源实现只是在每次请求的时候简单的打开和关闭一个连接。虽然这有点慢，但作为一些不需要性能和立即响应简单应用来说 ，不失为一种好选择 。POOLED - 这个数据源缓存 JDBC 连接对象用于避免每次都要连接和生成连接实例而需要的验证时间 。对于并发WEB应用，这种方式非常流行因为它有最快的响应时间。JNDI - 这个数据源实现是为了准备和 Spring 或应用服务一起使用，可以在外部也可以在内部配置这个数据源，然后在JNDI上下文中引用它 4.log4j在config目录下新建log4j.properties复制下方代码:123456# Global logging configurationlog4j.rootLogger=DEBUG, stdout# Console output...log4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern=%5p [%t] - %m%n 5.核心映射文件在config下新建mapper包,在包内新建UserMapper.xml(名称随意..)参考以下代码:123456789101112&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//ibatis.apache.org//DTD Mapper 3.0//EN\" \"http://ibatis.apache.org/dtd/ibatis-3-mapper.dtd\"&gt; &lt;mapper namespace=\"user\" &gt; &lt;select id =\"getUsers\" resultType=\"com.entiy.User\"&gt; SELECT * FROM USER &lt;/select&gt; &lt;select id=\"findUserById\" parameterType=\"int\" resultType=\"com.test.User\"&gt; SELECT * FROM USER WHERE id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; 5.1.SQL 映射文件结构：注:第一次使用仅作为了解就可以了cache - 配置给定命名空间的缓存。cache-ref – 从其他命名空间引用缓存配置。resultMap – 最复杂，也是最有力量的元素，用来描述如何从数据库结果集中来加载对象。 sql – 可以重用的 SQL 块，也可以被其他语句引用。insert – 映射插入语句update – 映射更新语句delete – 映射删除语句select – 映射查询语句 6.Java代码这里直接在main方法中写的:12345678910111213141516171819202122232425262728293031323334353637383940package com.fly;import java.io.InputStream;import java.util.List;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import com.entiy.User;public class Test &#123; public static void main(String[] args) &#123; SqlSession session = null; //声明配置文件 String resource = \"sqlMapConfig.xml\"; try &#123; //读取全局配置文件 InputStream is = Resources.getResourceAsStream(resource); //创建SqlSessionFactory会话工厂 SqlSessionFactoryBuilder ssfb = new SqlSessionFactoryBuilder(); SqlSessionFactory ssf = ssfb.build(is); //获取SqlSession会话 session = ssf.openSession(); //拿到结果集放入List集合 List&lt;User&gt; list = session.selectList(\"user.getUsers\"); //遍历输出 for(User u:list)&#123; System.out.println(u.toString()); &#125; &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125;finally&#123; //关闭资源 if(session != null)&#123; session.close(); &#125; &#125; &#125;&#125; 6.1.SqlSessionFactoryBuilder的生命周期：这个类可以被初始 、 使用和丢弃 ， 如果你已经创建好了一个 SqlSessionFactory 后就不用再保留它 。 因此 ，SqlSessionFactoryBuilder 的最好作用域是方法体内，比如说定义一个方法变量。你可以重复使 用SqlSessionFactoryBuilder 生成多个SqlSessionFactory 实例 ， 但是最好不要强行保留 ， 因为 XML 的解析资源要用来做其它更重要的事。 6.2.SqlSessionFactory：一旦创建， SqlSessionFactory 就会在整个应用过程中始终存在。所以没有理由去销毁和再创建它，一个应用运行中也不建议多次创建 SqlSessionFactory 。 如果真的那样做 ， 会显得很拙劣 。 因此 SqlSessionFactor y最好的作用域是 Application 。可以有多种方法实现。最简单的方法是单例模式或者是静态单例模式 。 然而这既不是广泛赞成和好用的 。 反而 ， 使用 Google Guice 或 Spring 来进行依赖反射会更好 。 这些框架允许你生成管理器来管理 SqlSessionFactory 的单例生命周期。 6.3.SqlSession：每个线程都有自己的 SqlSession 实例， SqlSession 实例是不能被共享，也是不是线程安全的。因此最好使用 Request 作用域或者方法体作用域。不要使用类的静态变量来引用一个 SqlSession 实例，甚至不要使用类的一个实例变更来引用。如果你正在使用 WEB 框架，应该让 SqlSession 跟随 HTTP 请求的相似作用域。也就是说，在收到一个 HTTP 请求过后，打开 SqlSession ，等返回一个回应以后，立马关掉这个 SqlSession 。 关闭 SqlSession 是非常重要的。你必须要确保 SqlSession 在 finally 方法体中正常关闭","categories":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://www.perfree.top/categories/MyBatis/"}],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://www.perfree.top/tags/MyBatis/"}]},{"title":"第一篇博客","slug":"hello-world","date":"2018-06-01T06:58:42.967Z","updated":"2018-06-04T10:18:43.116Z","comments":true,"path":"2018/06/01/hello-world/","link":"","permalink":"http://www.perfree.top/2018/06/01/hello-world/","excerpt":"","text":"第一次使用 Hexo来搭建个人博客! 还是蛮兴奋的^_^… 下面的信息就作为一个入门的备份吧: hexo官方文档 故障排除 Hexo/GitHub. 快速开始创建一个新帖子1$ hexo new \"My New Post\" 更多信息: 写作 运行服务器1$ hexo server 更多信息: 服务器 生成静态文件(网页)1$ hexo generate 更多信息: 生成 部署到远程站点1$ hexo deploy 更多信息: 部署","categories":[],"tags":[]}]}