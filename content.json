{"meta":{"title":"Perfree","subtitle":"学而时习之,不亦说乎","description":"云淡风轻","author":"Perfree","url":"http://www.perfree.top"},"pages":[{"title":"","date":"2018-06-13T09:19:43.701Z","updated":"2018-06-04T03:59:10.904Z","comments":false,"path":"tags/index.html","permalink":"http://www.perfree.top/tags/index.html","excerpt":"","text":""},{"title":"","date":"2018-06-13T09:19:43.699Z","updated":"2018-06-04T03:59:40.398Z","comments":false,"path":"categories/index.html","permalink":"http://www.perfree.top/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"动态SQL","slug":"2018-06-13","date":"2018-06-13T10:34:38.000Z","updated":"2018-06-13T12:23:49.749Z","comments":true,"path":"2018/06/13/2018-06-13/","link":"","permalink":"http://www.perfree.top/2018/06/13/2018-06-13/","excerpt":"","text":"MyBatis 的强大特性之一便是它的动态 SQL 能力。如果你有使用 JDBC 或其他类似框架的经验，你就能体会到根据不同条件拼接 SQL 字符串有多么痛苦。拼接的时候要确保不能忘了必要的空格，还要注意省掉列名列表最后的逗号。利用动态 SQL 这一特性可以彻底摆脱这种痛苦。 通常使用动态 SQL 不可能是独立的一部分,MyBatis 当然使用一种强大的动态 SQL 语言来改进这种情形,这种语言可以被用在任意映射的 SQL 语句中。 动态 SQL 元素和使用 JSTL 或其他相似的基于 XML 的文本处理器相似。在 MyBatis 之前的版本中,有很多的元素需要来了解。MyBatis 3 大大提升了它们,现在用不到原先一半的元素就能工作了。MyBatis 采用功能强大的基于 OGNL 的表达式来消除其他元素。–摘至 官方文档 if+where语句如果查询条件有多个，并且是可任意选择的，那么我们就需要采用动态条件查询技巧代码示例(ps:不知道为什么一上传缩进就变了,凑合看吧..):1234567891011121314151617181920&lt;select id=\"findUsers\" parameterType=\"user\" resultType=\"user\"&gt; SELECT id,username,birthday,sex,address FROM t_user &lt;where&gt; &lt;if test=\"username != null and username != ''\"&gt; and username like '%$&#123;username&#125;%' &lt;/if&gt; &lt;if test=\"sex != null and sex != ''\"&gt; and sex=#&#123;sex&#125; &lt;/if&gt; &lt;if test=\"id != null and id != ''\"&gt; and id=#&#123;id&#125; &lt;/if&gt; &lt;if test=\"birthday != null and birthday != ''\"&gt; and birthday=#&#123;birthday&#125; &lt;/if&gt; &lt;if test=\"address != null and address != ''\"&gt; and address=#&#123;address&#125; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; (1) where这个标签会知道如果它包含的标签中有返回值的话，它就插入一个‘where’。此外，如果标签返回的内容是以AND 或OR 开头的，它就会剔除掉。(2) if这个应该都明白,如果没有动态SQL语句,你该怎么实现~~想想都可怕… if+set语句和上边where基本一致,示例代码:123456789101112&lt;update id=\"updateUserById\" parameterType=\"user\"&gt; UPDATE t_user &lt;set&gt; &lt;if test=\"username != null and username != ''\"&gt; username=#&#123;username&#125; &lt;/if&gt; &lt;if test=\"sex != null and sex != ''\"&gt; sex = #&#123;sex&#125; &lt;/if&gt; &lt;/set&gt; WHERE id = #&#123;id&#125;&lt;/update&gt; 这个时候根据id修改用户信息时就会做出一个判断,如果username为空,sex有值,这时候便会修改sex choose(when,otherwise)语句只选择一个作为查询条件,类似于java中的switch语句示例代码:12345678910111213141516&lt;select id=\"selectUserByChoose\" resultType=\"user\"&gt; SELECT * FROM t_user &lt;where&gt; &lt;choose&gt; &lt;when test=\"id != null and id!= ''\"&gt; id=#&#123;id&#125; &lt;/when&gt; &lt;when test=\"sex != null and sex != ''\"&gt; sex=#&#123;sex&#125; &lt;/when&gt; &lt;otherwise&gt; and username=#&#123;username&#125; &lt;/otherwise&gt; &lt;/choose&gt; &lt;/where&gt;&lt;/select&gt; 这里有三个条件,如果id不为空那么就会根据id查询信息,如果为空,就会看sex是否为空,如果sex不为空,就会根据sex查询信息,同理,如果sex为空,就会执行条件为username的查询 trim语句trim标记是一个格式化的标记，可以完成set或者是where标记的功能代码示例:1234567891011&lt;select id=\"selectUserByTrim\" resultType=\"user\"&gt; SELECT * FROM t_user &lt;trim prefix=\"where\" prefixOverrides=\"and | or\"&gt; &lt;if test=\"username != null and username != ''\"&gt; and username=#&#123;username&#125; &lt;/if&gt; &lt;if test=\"sex != null and sex != ''\"&gt; and sex = #&#123;sex&#125; &lt;/if&gt; &lt;/trim&gt;&lt;/select&gt; 属性prefix：前缀 prefixoverride：去掉第一个and或者是orsuffix：后缀 suffixoverride：去掉最后一个逗号（也可以是其他的标记，就像是上面前缀中的and一样） SQL片段有时候可能某个 sql 语句我们用的特别多，为了增加代码的重用性，简化代码，我们需要将这些代码抽取出来，然后使用时直接调用比如查询user表的判断,查询到结果的列名,代码示例:123456789101112131415161718192021&lt;!-- sql片段 --&gt;&lt;sql id=\"query_user_where\"&gt; &lt;if test=\"username != null and username != ''\"&gt; and username like '%$&#123;username&#125;%' &lt;/if&gt; &lt;if test=\"sex != null and sex != ''\"&gt; and sex=#&#123;sex&#125; &lt;/if&gt; &lt;if test=\"id != null and id != ''\"&gt; and id=#&#123;id&#125; &lt;/if&gt; &lt;if test=\"birthday != null and birthday != ''\"&gt; and birthday=#&#123;birthday&#125; &lt;/if&gt; &lt;if test=\"address != null and address != ''\"&gt; and address=#&#123;address&#125; &lt;/if&gt;&lt;/sql&gt;&lt;sql id=\"select_user_where\"&gt; id,username,birthday,sex,address&lt;/sql&gt; 引用SQL片段示例:12345678&lt;select id=\"findUsers\" parameterType=\"user\" resultType=\"user\"&gt; SELECT &lt;include refid=\"select_user_where\"/&gt; FROM t_user &lt;where&gt; &lt;include refid=\"query_user_where\"/&gt; &lt;/where&gt;&lt;/select&gt; 注意：最好基于 单表来定义sql片段，提高片段的可重用性,另外在sql 片段中不要包括where foreach语句如果我们需要批量删除用户的话,我们可以使用foreach语句来完成,代码示例:123456789&lt;!-- 批量删除 --&gt;&lt;delete id=\"batchDeleteUsers\" parameterType=\"usercustom\"&gt; DELETE FROM t_user &lt;where&gt; &lt;foreach collection=\"ids\" item=\"uid\" open=\"(\" close=\")\" separator=\"or\"&gt; id=#&#123;uid&#125; &lt;/foreach&gt; &lt;/where&gt;&lt;/delete&gt; 先贴上最终的sql语句1DELETE FROM t_user WHERE ( id=? or id=? or id=? ) 说明:parameterType定义的usercustom为我们自定义的一个类,用List来存储要删除的用户id,之后我们再使用foreach来批量删除属性:collection:指定输入对象中的集合属性item:集合中遍历的值open:开始遍历时拼接的字符串close:结束遍历时拼接的字符串separator:遍历对象中需要拼接的字符串 总结在编写动态SQL语句之前一定要写原生的sql语句出来,保证可运行,再通过mybatis动态sql照着改,降低出错率!","categories":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://www.perfree.top/categories/MyBatis/"}],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://www.perfree.top/tags/MyBatis/"}]},{"title":"MyBatis Mapper代理的开发方式","slug":"2018-06-12","date":"2018-06-12T10:07:07.000Z","updated":"2018-06-12T10:49:35.097Z","comments":true,"path":"2018/06/12/2018-06-12/","link":"","permalink":"http://www.perfree.top/2018/06/12/2018-06-12/","excerpt":"","text":"Mapper接口开发方法只需要程序员编写Mapper接口（相当于Dao接口），由Mybatis框架根据接口定义创建接口的动态代理对象，代理对象的方法体同上边Dao接口实现类方法。同时mybatis官方也推荐使用mapper代理方法开发mapper接口，程序员不用编写mapper接口实现类，使用mapper代理方法时，输入参数可以使用pojo包装对象或map对象，保证dao的通用性。 1.开发规范(1) Mapper.xml文件中的namespace与mapper接口的类路径相同。(2) Mapper接口方法名和Mapper.xml中定义的每个statement的id相同(3) Mapper接口方法的输入参数类型和mapper.xml中定义的每个sql 的parameterType的类型相同(4) Mapper接口方法的输出参数类型和mapper.xml中定义的每个sql的resultType的类型相同 2.Mapper.xml映射文件定义mapper映射文件UserMapper.xml,需要修改如下几项: (1) namespace的值为UserMapper接口的路径(2) parameterType要和接口定义的输入参数类型保持一致(3) resultType同样和接口中定义的输出(返回)参数类型保持一致,如果返回的值类型为List,直接定义为实体存储对象即可,这和selectOne或selectList有关 代码示例:123456789101112&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"com.fly.mapper.UserMapper\"&gt; &lt;select id=\"findUserById\" parameterType=\"int\" resultType=\"user\"&gt; SELECT * FROM t_user WHERE id = #&#123;id&#125; &lt;/select&gt; &lt;update id=\"updateUserById\" parameterType=\"user\"&gt; UPDATE t_user SET username = #&#123;username&#125; WHERE id = #&#123;id&#125; &lt;/update&gt;&lt;/mapper&gt; 3.Mapper.java接口文件接口的定义需注意以下几项: (1) Mapper接口方法名和Mapper.xml中定义的statement的id相同(2) Mapper接口方法的输入参数类型和mapper.xml中定义的statement的parameterType的类型相同(3) Mapper接口方法的输出参数类型和mapper.xml中定义的statement的resultType的类型相同 代码示例:12345678910package com.fly.mapper;import com.fly.pojo.User;public interface UserMapper &#123; //根据id查找用户信息 public User findUserById(int id); //根据id修改用户名称 public void updateUserById(User user);&#125; 4.加载Mapper.xml映射文件在sqlMapConfig.xml做如下修改(多种方式加载):12345678&lt;mappers&gt; &lt;!-- 通过mapper代理接口加载mapper配置文件mapper接口和映射文件名称相同，且在同一目录下面 --&gt; &lt;!-- &lt;mapper class=\"com.fly.mapper.UserMapper\"/&gt; --&gt; &lt;!-- 单个加载映射文件 --&gt; &lt;mapper resource=\"mapper/UserMapper.xml\"/&gt; &lt;!-- 批量加载映射文件 必须保证mapper配置文件mapper接口和映射文件名称相同且在同一目录下面 --&gt; &lt;!-- &lt;package name=\"com.fly.mapper\"/&gt; --&gt;&lt;/mappers&gt; 5.测试这里使用了junit进行测试: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package com.fly.test;import java.io.InputStream;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.Before;import org.junit.Test;import com.fly.mapper.UserMapper;import com.fly.pojo.User;public class MybatisTest &#123; private SqlSessionFactory ssf; @Before public void createSqlSessionFactory() throws Exception&#123; String resource = \"sqlMapConfig.xml\"; InputStream is = Resources.getResourceAsStream(resource); //使用SqlSessionFactoryBuilder创建sessionFactory SqlSessionFactoryBuilder ssfb = new SqlSessionFactoryBuilder(); ssf=ssfb.build(is); &#125; @Test public void findUserById()&#123; //获取session SqlSession session = ssf.openSession(); //创建usermapper对象，mybatis自动生成mapper代理对象 UserMapper mapper = session.getMapper(UserMapper.class); //调用代理对象方法 User u = mapper.findUserById(10); System.out.println(u); //关闭session session.close(); &#125; @Test public void updateUserById()&#123; //获取session SqlSession session = ssf.openSession(); //创建usermapper对象，mybatis自动生成mapper代理对象 UserMapper mapper = session.getMapper(UserMapper.class); User u = new User(); u.setId(10); u.setUsername(\"小钢炮\"); //调用代理对象方法 mapper.updateUserById(u); //提交 session.commit(); //关闭session session.close(); &#125;&#125; 6.总结(1) selectOne和selectList 如果mapper方法返回单个pojo对象（非集合对象），代理对象内部通过selectOne查询数据库。 如果mapper方法返回集合对象，代理对象内部通过selectList查询数据库。 (2) namespace (重申)Mapper.xml文件中的namespace与mapper接口的类路径一定要相同。 7.最后扩展下#{}和${}(1) #{} #{}表示一个占位符号，#{}接收输入参数，类型可以是简单类型，pojo、hashmap。 如果接收简单类型，#{}中可以写成value或其它名称。 #{}接收pojo对象值，通过OGNL读取对象中的属性值，通过属性.属性.属性...的方式获取对象属性值。 (2) ${} ${}表示一个拼接符号，会引用sql注入，所以不建议使用${} ${}接收输入参数，类型可以是简单类型，pojo、hashmap。 如果接收简单类型，${}中只能写成value。 ${}接收pojo对象值，通过OGNL读取对象中的属性值，通过属性.属性.属性…的方式获取对象属性值。","categories":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://www.perfree.top/categories/MyBatis/"}],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://www.perfree.top/tags/MyBatis/"}]},{"title":"初次配置使用MyBatis","slug":"2018-06-11","date":"2018-06-11T08:22:18.000Z","updated":"2018-06-13T12:14:36.606Z","comments":true,"path":"2018/06/11/2018-06-11/","link":"","permalink":"http://www.perfree.top/2018/06/11/2018-06-11/","excerpt":"","text":"MyBatis是一款支持定制化SQL,存储过程以及高级映射的优秀的持久层框架。MyBatis 避免了几乎所有的 JDBC 代码和手工设置参数以及抽取结果集。MyBatis 使用简单的 XML 或注解来配置和映射基本体，将接口和 Java 的 POJOs(Plain Old Java Objects,普通的 Java对象)映射成数据库中的记录。官方文档 1.下载MyBatis官方下载地址这里使用的是mybatis-3.4.6.zip 2.导包将下载的压缩包解压,导入里边所有jar包(一共13个…),之后再导入所使用的数据库jar包就ok了,这里使用的是MySql数据库 3.全局配置web项目在Java Resources新建config资源目录,在该目录下新建MyBatis全局配置文件sqlMapConfig.xml(名称随意),它包含了数据源和事务管理器等设置和属性信息,基础环境配置:12345678910111213141516171819202122232425&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE configurationPUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"\"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt; &lt;environments default=\"development\"&gt; &lt;environment id=\"development\"&gt; &lt;transactionManager type=\"JDBC\"/&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;!-- 数据库连接配置 --&gt; &lt;property name=\"driver\" value=\"$&#123;driver&#125;\"/&gt; &lt;property name=\"url\" value=\"$&#123;url&#125;\"/&gt; &lt;property name=\"username\" value=\"$&#123;username&#125;\"/&gt; &lt;property name=\"password\" value=\"$&#123;password&#125;\"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;environment id=\"development2\"&gt; &lt;!--核心映射文件地址,示例如下(可使用相对路径或者绝对路径)--&gt; &lt;mapper resource=\"mapper/UserMapper.xml\"/&gt; &lt;!--绝对路径--&gt; &lt;mapper url=\"file:///var/sqlmaps/AuthorMapper.xml\"/&gt; ...... &lt;/environment&gt; &lt;/environments&gt; &lt;/configuration&gt; 3.1.MyBatis 事务管理类JDBC - 这个类型直接全部使用 JDBC 的提交和回滚功能。它依靠使用连接的数据源来管理事务的作用域。MANAGED - 这个类型什么不做 ， 它从不提交 、 回滚和关闭连接 。 而是让窗口来管理事务的全部生命周期 。（比如说 Spring 或者JAVAEE 服务器） 3.2.MyBatis 数据源类型UNPOOLED -这个数据源实现只是在每次请求的时候简单的打开和关闭一个连接。虽然这有点慢，但作为一些不需要性能和立即响应简单应用来说 ，不失为一种好选择 。POOLED - 这个数据源缓存 JDBC 连接对象用于避免每次都要连接和生成连接实例而需要的验证时间 。对于并发WEB应用，这种方式非常流行因为它有最快的响应时间。JNDI - 这个数据源实现是为了准备和 Spring 或应用服务一起使用，可以在外部也可以在内部配置这个数据源，然后在JNDI上下文中引用它 4.log4j在config目录下新建log4j.properties复制下方代码:123456# Global logging configurationlog4j.rootLogger=DEBUG, stdout# Console output...log4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern=%5p [%t] - %m%n 5.核心映射文件在config下新建mapper包,在包内新建UserMapper.xml(名称随意..)参考以下代码:123456789101112&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//ibatis.apache.org//DTD Mapper 3.0//EN\" \"http://ibatis.apache.org/dtd/ibatis-3-mapper.dtd\"&gt; &lt;mapper namespace=\"user\" &gt; &lt;select id =\"getUsers\" resultType=\"com.entiy.User\"&gt; SELECT * FROM USER &lt;/select&gt; &lt;select id=\"findUserById\" parameterType=\"int\" resultType=\"com.test.User\"&gt; SELECT * FROM USER WHERE id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; 5.1.SQL 映射文件结构：注:第一次使用仅作为了解就可以了cache - 配置给定命名空间的缓存。cache-ref – 从其他命名空间引用缓存配置。resultMap – 最复杂，也是最有力量的元素，用来描述如何从数据库结果集中来加载对象。 sql – 可以重用的 SQL 块，也可以被其他语句引用。insert – 映射插入语句update – 映射更新语句delete – 映射删除语句select – 映射查询语句 6.Java代码这里直接在main方法中写的:12345678910111213141516171819202122232425262728293031323334353637383940package com.fly;import java.io.InputStream;import java.util.List;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import com.entiy.User;public class Test &#123; public static void main(String[] args) &#123; SqlSession session = null; //声明配置文件 String resource = \"sqlMapConfig.xml\"; try &#123; //读取全局配置文件 InputStream is = Resources.getResourceAsStream(resource); //创建SqlSessionFactory会话工厂 SqlSessionFactoryBuilder ssfb = new SqlSessionFactoryBuilder(); SqlSessionFactory ssf = ssfb.build(is); //获取SqlSession会话 session = ssf.openSession(); //拿到结果集放入List集合 List&lt;User&gt; list = session.selectList(\"user.getUsers\"); //遍历输出 for(User u:list)&#123; System.out.println(u.toString()); &#125; &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125;finally&#123; //关闭资源 if(session != null)&#123; session.close(); &#125; &#125; &#125;&#125; 6.1.SqlSessionFactoryBuilder的生命周期：这个类可以被初始 、 使用和丢弃 ， 如果你已经创建好了一个 SqlSessionFactory 后就不用再保留它 。 因此 ，SqlSessionFactoryBuilder 的最好作用域是方法体内，比如说定义一个方法变量。你可以重复使 用SqlSessionFactoryBuilder 生成多个SqlSessionFactory 实例 ， 但是最好不要强行保留 ， 因为 XML 的解析资源要用来做其它更重要的事。 6.2.SqlSessionFactory：一旦创建， SqlSessionFactory 就会在整个应用过程中始终存在。所以没有理由去销毁和再创建它，一个应用运行中也不建议多次创建 SqlSessionFactory 。 如果真的那样做 ， 会显得很拙劣 。 因此 SqlSessionFactor y最好的作用域是 Application 。可以有多种方法实现。最简单的方法是单例模式或者是静态单例模式 。 然而这既不是广泛赞成和好用的 。 反而 ， 使用 Google Guice 或 Spring 来进行依赖反射会更好 。 这些框架允许你生成管理器来管理 SqlSessionFactory 的单例生命周期。 6.3.SqlSession：每个线程都有自己的 SqlSession 实例， SqlSession 实例是不能被共享，也是不是线程安全的。因此最好使用 Request 作用域或者方法体作用域。不要使用类的静态变量来引用一个 SqlSession 实例，甚至不要使用类的一个实例变更来引用。如果你正在使用 WEB 框架，应该让 SqlSession 跟随 HTTP 请求的相似作用域。也就是说，在收到一个 HTTP 请求过后，打开 SqlSession ，等返回一个回应以后，立马关掉这个 SqlSession 。 关闭 SqlSession 是非常重要的。你必须要确保 SqlSession 在 finally 方法体中正常关闭","categories":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://www.perfree.top/categories/MyBatis/"}],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://www.perfree.top/tags/MyBatis/"}]},{"title":"第一篇博客","slug":"hello-world","date":"2018-05-10T10:07:07.000Z","updated":"2018-06-13T09:15:22.747Z","comments":true,"path":"2018/05/10/hello-world/","link":"","permalink":"http://www.perfree.top/2018/05/10/hello-world/","excerpt":"","text":"第一次使用 Hexo来搭建个人博客! 还是蛮兴奋的^_^… 下面的信息就作为一个入门的备份吧: hexo官方文档 故障排除 Hexo/GitHub. 快速开始创建一个新帖子1$ hexo new \"My New Post\" 更多信息: 写作 运行服务器1$ hexo server 更多信息: 服务器 生成静态文件(网页)1$ hexo generate 更多信息: 生成 部署到远程站点1$ hexo deploy 更多信息: 部署","categories":[{"name":"其他","slug":"其他","permalink":"http://www.perfree.top/categories/其他/"}],"tags":[{"name":"其他","slug":"其他","permalink":"http://www.perfree.top/tags/其他/"}]}]}