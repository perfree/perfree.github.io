{"meta":{"title":"Perfree","subtitle":"学而时习之,不亦说乎","description":"云淡风轻","author":"Perfree","url":"http://www.perfree.top"},"pages":[{"title":"","date":"2018-06-13T09:19:43.701Z","updated":"2018-06-04T03:59:10.904Z","comments":false,"path":"tags/index.html","permalink":"http://www.perfree.top/tags/index.html","excerpt":"","text":""},{"title":"","date":"2018-06-13T09:19:43.699Z","updated":"2018-06-04T03:59:40.398Z","comments":false,"path":"categories/index.html","permalink":"http://www.perfree.top/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"Hibernate配置","slug":"2018-06-21","date":"2018-07-06T06:54:29.000Z","updated":"2018-07-06T05:54:33.575Z","comments":true,"path":"2018/07/06/2018-06-21/","link":"","permalink":"http://www.perfree.top/2018/07/06/2018-06-21/","excerpt":"","text":"什么是Hibernate?Hibernate是一个开放源代码的对象关系映射框架，通过对JDBC进行了轻量级的对象封装，使Java程序员能随心所欲的使用面向对象的编程思维来操作数据库 准备工作导入Hibernate的jar包和mysql的jar包 核心配置文件一般在新建一个资源目录config(也可以直接在src下),新建hibernate.cfg.xml将如下代码放入1234567891011121314151617181920212223&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE hibernate-configuration PUBLIC \"-//Hibernate/Hibernate Configuration DTD 3.0//EN\" \"http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd\"&gt;&lt;hibernate-configuration&gt; &lt;session-factory&gt; &lt;!-- 连接mysql数据库配置 --&gt; &lt;property name=\"hibernate.connection.driver_class\"&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;property name=\"hibernate.connection.url\"&gt;jdbc:mysql:///hibernate?characterEncoding=utf-8&lt;/property&gt; &lt;property name=\"hibernate.connection.username\"&gt;root&lt;/property&gt; &lt;property name=\"hibernate.connection.password\"&gt;121121&lt;/property&gt; &lt;!-- 使用mysql方言 --&gt; &lt;property name=\"hibernate.dialect\"&gt;org.hibernate.dialect.MySQLDialect&lt;/property&gt; &lt;!-- 是否在控制台显示sql语句 --&gt; &lt;property name=\"hibernate.show_sql\"&gt;true&lt;/property&gt; &lt;!-- 是否美化sql语句 --&gt; &lt;property name=\"hibernate.format_sql\"&gt;true&lt;/property&gt; &lt;!-- 如果表不存在是否自动创建表 --&gt; &lt;property name=\"hibernate.hbm2ddl.auto\"&gt;update&lt;/property&gt; &lt;!-- 制定session与当前线程绑定 --&gt; &lt;property name=\"hibernate.current_session_context_class\"&gt;thread&lt;/property&gt; &lt;/session-factory&gt;&lt;/hibernate-configuration&gt; 以上的配置都可以通过Hibernate发布包的etc路径下的hibernate.properties找到,左边为name,右边为值,示例:12&lt;!-- #hibernate.connection.url jdbc:mysql:///test对应写法为 --&gt;&lt;property name=\"hibernate.connection.url\"&gt;jdbc:mysql:///test&lt;/property&gt; 创建实体类尽量使用封装数据类型,提供get,set方法123456789101112131415161718192021222324252627282930313233343536373839package com.fly.pojo;public class Customer &#123; /*`cid` bigint(32) NOT NULL AUTO_INCREMENT COMMENT '客户编号(主键)', `name` varchar(32) NOT NULL COMMENT '客户名称(公司名称)', `userId` bigint(32) DEFAULT NULL COMMENT '负责人id', `createId` bigint(32) DEFAULT NULL COMMENT '创建人id', `source` varchar(32) DEFAULT NULL COMMENT '客户信息来源', `industry` varchar(32) DEFAULT NULL COMMENT '客户所属行业', `level` varchar(32) DEFAULT NULL COMMENT '客户级别', `linkman` varchar(64) DEFAULT NULL COMMENT '联系人', `phone` varchar(64) DEFAULT NULL COMMENT '固定电话', `mobile` varchar(16) DEFAULT NULL COMMENT '移动电话',*/ private Long cid; private String name; private Long userId; private Long createId; private String source; private String industry; private String level; private String linkman; private String phone; private String mobile; public Long getCid() &#123; return cid; &#125; public void setCid(Long cid) &#123; this.cid = cid; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Long getUserId() &#123; return userId; &#125; ....... 映射文件123456789101112131415161718192021222324252627282930&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC \"-//Hibernate/Hibernate Mapping DTD 3.0//EN\" \"http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd\"&gt;&lt;hibernate-mapping&gt; &lt;!-- name:对应实体类的全限定名 table:对应数据库中哪张表 --&gt; &lt;class name=\"com.fly.pojo.Customer\" table=\"customer\"&gt; &lt;!-- name:主键的名字 column:主键的列名 generator class=\"native\":让数据库自动选择怎么生成主键 --&gt; &lt;id name=\"cid\" column=\"cid\"&gt; &lt;generator class=\"native\"&gt;&lt;/generator&gt; &lt;/id&gt; &lt;!-- name:属性名,column:列名 --&gt; &lt;property name=\"name\" column=\"name\"&gt;&lt;/property&gt; &lt;property name=\"userId\" column=\"userId\"&gt;&lt;/property&gt; &lt;property name=\"createId\" column=\"createId\"&gt;&lt;/property&gt; &lt;property name=\"source\" column=\"source\"&gt;&lt;/property&gt; &lt;property name=\"industry\" column=\"industry\"&gt;&lt;/property&gt; &lt;property name=\"level\" column=\"level\"&gt;&lt;/property&gt; &lt;property name=\"linkman\" column=\"linkman\"&gt;&lt;/property&gt; &lt;property name=\"phone\" column=\"phone\"&gt;&lt;/property&gt; &lt;property name=\"mobile\" column=\"mobile\"&gt;&lt;/property&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; 将映射文件的地址加载进核心配置文件,在核心配置文件添加mapping:12345678910111213141516171819202122232425&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE hibernate-configuration PUBLIC \"-//Hibernate/Hibernate Configuration DTD 3.0//EN\" \"http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd\"&gt;&lt;hibernate-configuration&gt; &lt;session-factory&gt; &lt;!-- 连接mysql数据库配置 --&gt; &lt;property name=\"hibernate.connection.driver_class\"&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;property name=\"hibernate.connection.url\"&gt;jdbc:mysql:///hibernate_demo?characterEncoding=utf-8&lt;/property&gt; &lt;property name=\"hibernate.connection.username\"&gt;root&lt;/property&gt; &lt;property name=\"hibernate.connection.password\"&gt;121121&lt;/property&gt; &lt;!-- 使用mysql方言 --&gt; &lt;property name=\"hibernate.dialect\"&gt;org.hibernate.dialect.MySQLDialect&lt;/property&gt; &lt;!-- 是否在控制台显示sql语句 --&gt; &lt;property name=\"hibernate.show_sql\"&gt;true&lt;/property&gt; &lt;!-- 是否美化sql语句 --&gt; &lt;property name=\"hibernate.format_sql\"&gt;true&lt;/property&gt; &lt;!-- 如果表不存在是否自动创建表 --&gt; &lt;property name=\"hibernate.hbm2ddl.auto\"&gt;update&lt;/property&gt; &lt;!-- 制定session与当前线程绑定 --&gt; &lt;property name=\"hibernate.current_session_context_class\"&gt;thread&lt;/property&gt; &lt;!-- 加载映射文件,如有多个可以配置多个 --&gt; &lt;mapping resource=\"\\com\\fly\\pojo\\Customer.hbm.xml\"/&gt; &lt;/session-factory&gt;&lt;/hibernate-configuration&gt; 测试123456789101112131415161718192021222324252627282930package com.fly.test;import org.hibernate.Session;import org.hibernate.SessionFactory;import org.hibernate.Transaction;import org.hibernate.cfg.Configuration;import org.junit.Test;import com.fly.pojo.Customer;public class HibernateTest &#123; @Test public void fun()&#123; //创建session工厂 SessionFactory sessionFactory = new Configuration().configure().buildSessionFactory(); //获取session Session session = sessionFactory.getCurrentSession(); //开启事务 Transaction tx = session.beginTransaction(); //添加一些信息 Customer customer = new Customer(); customer.setName(\"xx公司\"); customer.setLevel(\"张三\"); customer.setMobile(\"00123\"); //向数据库保存刚添加的信息 session.save(customer); //提交 tx.commit(); &#125;&#125; 运行结果():1234567Hibernate: insert into customer (name, userId, createId, source, industry, level, linkman, phone, mobile) values (?, ?, ?, ?, ?, ?, ?, ?, ?) 这时再看数据库,表,数据都创建了","categories":[{"name":"Hibernate","slug":"Hibernate","permalink":"http://www.perfree.top/categories/Hibernate/"}],"tags":[{"name":"Hibernate","slug":"Hibernate","permalink":"http://www.perfree.top/tags/Hibernate/"}]},{"title":"MyBatis一对一,一对多,多对多","slug":"2018-06-14","date":"2018-06-14T10:34:38.000Z","updated":"2018-06-14T09:44:42.144Z","comments":true,"path":"2018/06/14/2018-06-14/","link":"","permalink":"http://www.perfree.top/2018/06/14/2018-06-14/","excerpt":"","text":"什么是一对一,一对多,多对多文字就不打了,直接上图: 一对一参考上面的关系图,简单的做一个一对一的测试,拿订单作为主表,用户作为从表,有两种方案实现，映射文件中输出映射使用resultType和resultMap。这里只关注映射文件，全局配置文件就不多说了，一样的配置… 方案1通过resultType实现,我们可以自定义一个类用来接收结果,让这个类继承orders类,之后我们再添加user示例代码:1234567891011121314151617181920212223242526272829public class OrdersCustom extends Orders&#123; private String username; private Date birthday; private char sex; private String address; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public Date getBirthday() &#123; return birthday; &#125; public void setBirthday(Date birthday) &#123; this.birthday = birthday; &#125; public char getSex() &#123; return sex; &#125; public void setSex(char sex) &#123; this.sex = sex; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125; OrdersMapper配置,因为我在全局配置文件定义了别名,所以resultType这里写了别名,如果没有定义,那么我们就需要书写自定义类全限定名示例代码:1234567891011121314&lt;!-- 一对一查询(自定义一个类) --&gt; &lt;select id=\"findOrdersUsers\" resultType=\"OrdersCustom\"&gt; SELECT o.*, u.username, u.birthday, u.sex, u.address FROM orders o, t_user u WHERE u.id = o.user_id &lt;/select&gt; 之后在测试类进行测试就ok啦 resultMap使用resultMap的话就不需要构造一个(自定义一个类)新的pojo，只需要将查询出来的记录的值通过resultMap帮我们映射到指定到哪个pojo的哪个属性上即可。关键字:association代码示例:12345678910111213141516171819202122232425262728&lt;!-- --&gt;&lt;resultMap type=\"orders\" id=\"orders_user\"&gt; &lt;id column=\"id\" property=\"id\"/&gt; &lt;result column=\"number\" property=\"number\"/&gt; &lt;result column=\"createtime\" property=\"createtime\"/&gt; &lt;result column=\"note\" property=\"note\"/&gt; &lt;association property=\"user\" javaType=\"user\"&gt; &lt;id column=\"user_id\" property=\"id\"/&gt; &lt;result column=\"username\" property=\"username\"/&gt; &lt;result column=\"birthday\" property=\"birthday\"/&gt; &lt;result column=\"sex\" property=\"sex\"/&gt; &lt;result column=\"address\" property=\"address\"/&gt; &lt;/association&gt; &lt;/resultMap&gt; &lt;!-- 一对一查询(map) --&gt; &lt;select id=\"findUsersOrders\" resultMap=\"orders_user\"&gt; SELECT o.*, u.username, u.birthday, u.sex, u.address FROM orders o, t_user u WHERE u.id = o.user_id &lt;/select&gt; 之后进行测试就好了.. 一对多通过一对一的案例之后,大概也就明白了使用resultMap和resultType的区别,所以下边的案例都只会演示resultMap的实现一对多,通过订单查询订单项,一个订单中可包含多个订单项orders实体类:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class Orders &#123; /* * id int(11) user_id int(11) number varchar(32) createtime datetime note varchar(100) */ private int id; private int user_id; private String number; private Date createtime; private String note; private List&lt;Orderdetail&gt; orderdetail; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public int getUser_id() &#123; return user_id; &#125; public void setUser_id(int user_id) &#123; this.user_id = user_id; &#125; public String getNumber() &#123; return number; &#125; public void setNumber(String number) &#123; this.number = number; &#125; public Date getCreatetime() &#123; return createtime; &#125; public void setCreatetime(Date createtime) &#123; this.createtime = createtime; &#125; public String getNote() &#123; return note; &#125; public void setNote(String note) &#123; this.note = note; &#125; public List&lt;Orderdetail&gt; getOrderdetail() &#123; return orderdetail; &#125; public void setOrderdetail(List&lt;Orderdetail&gt; orderdetail) &#123; this.orderdetail = orderdetail; &#125; 关键字:collection,ofTypeMapper示例:12345678910111213141516171819202122232425262728293031&lt;!-- 一对多查询订单,订单项,主表orders --&gt; &lt;resultMap type=\"orders\" id=\"getOrdersOrderdetailResultMap\"&gt; &lt;id column=\"oid\" property=\"id\"/&gt; &lt;result column=\"user_id\" property=\"user_id\"/&gt; &lt;result column=\"ocreatetime\" property=\"createtime\"/&gt; &lt;result column=\"note\" property=\"note\"/&gt; &lt;result column=\"number\" property=\"number\"/&gt; &lt;collection property=\"orderdetail\" ofType=\"orderdetail\"&gt; &lt;id column=\"odid\" property=\"id\"/&gt; &lt;result column=\"orders_id\" property=\"orders_id\"/&gt; &lt;result column=\"items_id\" property=\"items_id\"/&gt; &lt;result column=\"items_num\" property=\"items_num\"/&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;select id=\"getOrdersOrderdetail\" resultMap=\"getOrdersOrderdetailResultMap\"&gt; SELECT o.id oid, o.createtime ocreatetime, o.note, o.number, o.user_id, od.id odid, od.items_id, od.orders_id, od.items_num FROM orders o, orderdetail od WHERE o.id = od.orders_id &lt;/select&gt; 这里主要是关注，一对多时，resultMap中是如何实现的。使用collection。 多对多映射查询用户信息，以及它所购买的商品信息 user &gt; items主表: user从表: orders、orderdetail、items也就是通过查询某个user，查找到orders，通过orders查找到orderdetail，通过orderdetail查找到items。接下来修改我们的pojo实体类User:123456789101112public class User &#123; private int id; private String username; private Date birthday; private char sex; private String address; //一个用户可以拥有多个订单 private List&lt;Orders&gt; orders; public int getId() &#123; return id; &#125; ........ Orders:123456789101112public class Orders &#123; private int id; private int user_id; private String number; private Date createtime; private String note; //一个订单可以拥有多个订单项 private List&lt;Orderdetail&gt; orderdetail; public int getId() &#123; return id; &#125; ..... Orderdetail:1234567891011public class Orderdetail &#123; private int id; private int orders_id; private int items_id; private int items_num; //一个订单项只能拥有一个商品信息 private Items items; public int getId() &#123; return id; &#125; ....... Items(这个就不需要做改动了):1234567891011public class Items &#123; private int id; private String name; private float price; private String detail; private String pic; private Date createtime; public int getId() &#123; return id; &#125; ........ 之后就是Mapper文件了,其实只要理解了一对多,多对多相对来说也是很简单的,无非就是嵌套,这里利用了下sql片段,之前有说过示例:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;!-- 多对多查询用户,订单,订单明细,商品信息,sql片段 --&gt; &lt;sql id=\"getUsersItemsList\"&gt; u.id, u.username, u.sex, u.address, u.birthday, o.id oid, o.createtime ocreatetime, o.note, o.number, od.id odid, od.items_id, od.orders_id, od.items_num, i.createtime icreatetime, i.detail, i.`name`, i.pic, i.price &lt;/sql&gt; &lt;!-- 定义查询用户,订单,订单项,商品信息,resultMap --&gt; &lt;resultMap type=\"user\" id=\"getUsersItemsResultMap\"&gt; &lt;id column=\"id\" property=\"id\"/&gt; &lt;result column=\"username\" property=\"username\"/&gt; &lt;result column=\"sex\" property=\"sex\"/&gt; &lt;result column=\"address\" property=\"address\"/&gt; &lt;result column=\"birthday\" property=\"birthday\"/&gt; &lt;collection property=\"orders\" ofType=\"orders\"&gt; &lt;id column=\"oid\" property=\"id\"/&gt; &lt;result column=\"id\" property=\"user_id\"/&gt; &lt;result column=\"ocreatetime\" property=\"createtime\"/&gt; &lt;result column=\"note\" property=\"note\"/&gt; &lt;result column=\"number\" property=\"number\"/&gt; &lt;collection property=\"orderdetail\" ofType=\"orderdetail\"&gt; &lt;id column=\"odid\" property=\"id\"/&gt; &lt;result column=\"orders_id\" property=\"orders_id\"/&gt; &lt;result column=\"items_id\" property=\"items_id\"/&gt; &lt;result column=\"items_num\" property=\"items_num\"/&gt; &lt;collection property=\"items\" javaType=\"items\"&gt; &lt;id column=\"items_id\" property=\"id\"/&gt; &lt;result column=\"icreatetime\" property=\"createtime\"/&gt; &lt;result column=\"detail\" property=\"detail\"/&gt; &lt;result column=\"name\" property=\"name\"/&gt; &lt;result column=\"pic\" property=\"pic\"/&gt; &lt;result column=\"price\" property=\"price\"/&gt; &lt;/collection&gt; &lt;/collection&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;!-- 多对多,四张表查询用户,订单,订单明细,商品信息 --&gt; &lt;select id=\"getUsersItems\" resultMap=\"getUsersItemsResultMap\"&gt; SELECT &lt;include refid=\"getUsersItemsList\"/&gt; FROM t_user u, orders o, orderdetail od, items i WHERE u.id = o.user_id AND o.id = od.orders_id AND od.items_id = i.id &lt;/select&gt; 总结小技巧如果是一对一，那么就使用association,如果是一对多关系，那么就使用collection.多对多无非就是嵌套…不难懂。 resultType和resultMap(1)它俩都可以完成高级映射,如果没有特殊要求，使用resultType方便(2)应用场景不同,resultType主要是查询明细使用,resultMap主要是层级查询使用，比如查询用户信息，如何点击查询订单，再去查询订单信息另外,resultMap可以实现延迟加载,而resultType不行","categories":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://www.perfree.top/categories/MyBatis/"}],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://www.perfree.top/tags/MyBatis/"}]},{"title":"动态SQL","slug":"2018-06-13","date":"2018-06-13T10:34:38.000Z","updated":"2018-06-13T12:23:49.749Z","comments":true,"path":"2018/06/13/2018-06-13/","link":"","permalink":"http://www.perfree.top/2018/06/13/2018-06-13/","excerpt":"","text":"MyBatis 的强大特性之一便是它的动态 SQL 能力。如果你有使用 JDBC 或其他类似框架的经验，你就能体会到根据不同条件拼接 SQL 字符串有多么痛苦。拼接的时候要确保不能忘了必要的空格，还要注意省掉列名列表最后的逗号。利用动态 SQL 这一特性可以彻底摆脱这种痛苦。 通常使用动态 SQL 不可能是独立的一部分,MyBatis 当然使用一种强大的动态 SQL 语言来改进这种情形,这种语言可以被用在任意映射的 SQL 语句中。 动态 SQL 元素和使用 JSTL 或其他相似的基于 XML 的文本处理器相似。在 MyBatis 之前的版本中,有很多的元素需要来了解。MyBatis 3 大大提升了它们,现在用不到原先一半的元素就能工作了。MyBatis 采用功能强大的基于 OGNL 的表达式来消除其他元素。–摘至 官方文档 if+where语句如果查询条件有多个，并且是可任意选择的，那么我们就需要采用动态条件查询技巧代码示例(ps:不知道为什么一上传缩进就变了,凑合看吧..):1234567891011121314151617181920&lt;select id=\"findUsers\" parameterType=\"user\" resultType=\"user\"&gt; SELECT id,username,birthday,sex,address FROM t_user &lt;where&gt; &lt;if test=\"username != null and username != ''\"&gt; and username like '%$&#123;username&#125;%' &lt;/if&gt; &lt;if test=\"sex != null and sex != ''\"&gt; and sex=#&#123;sex&#125; &lt;/if&gt; &lt;if test=\"id != null and id != ''\"&gt; and id=#&#123;id&#125; &lt;/if&gt; &lt;if test=\"birthday != null and birthday != ''\"&gt; and birthday=#&#123;birthday&#125; &lt;/if&gt; &lt;if test=\"address != null and address != ''\"&gt; and address=#&#123;address&#125; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; (1) where这个标签会知道如果它包含的标签中有返回值的话，它就插入一个‘where’。此外，如果标签返回的内容是以AND 或OR 开头的，它就会剔除掉。(2) if这个应该都明白,如果没有动态SQL语句,你该怎么实现~~想想都可怕… if+set语句和上边where基本一致,示例代码:123456789101112&lt;update id=\"updateUserById\" parameterType=\"user\"&gt; UPDATE t_user &lt;set&gt; &lt;if test=\"username != null and username != ''\"&gt; username=#&#123;username&#125; &lt;/if&gt; &lt;if test=\"sex != null and sex != ''\"&gt; sex = #&#123;sex&#125; &lt;/if&gt; &lt;/set&gt; WHERE id = #&#123;id&#125;&lt;/update&gt; 这个时候根据id修改用户信息时就会做出一个判断,如果username为空,sex有值,这时候便会修改sex choose(when,otherwise)语句只选择一个作为查询条件,类似于java中的switch语句示例代码:12345678910111213141516&lt;select id=\"selectUserByChoose\" resultType=\"user\"&gt; SELECT * FROM t_user &lt;where&gt; &lt;choose&gt; &lt;when test=\"id != null and id!= ''\"&gt; id=#&#123;id&#125; &lt;/when&gt; &lt;when test=\"sex != null and sex != ''\"&gt; sex=#&#123;sex&#125; &lt;/when&gt; &lt;otherwise&gt; and username=#&#123;username&#125; &lt;/otherwise&gt; &lt;/choose&gt; &lt;/where&gt;&lt;/select&gt; 这里有三个条件,如果id不为空那么就会根据id查询信息,如果为空,就会看sex是否为空,如果sex不为空,就会根据sex查询信息,同理,如果sex为空,就会执行条件为username的查询 trim语句trim标记是一个格式化的标记，可以完成set或者是where标记的功能代码示例:1234567891011&lt;select id=\"selectUserByTrim\" resultType=\"user\"&gt; SELECT * FROM t_user &lt;trim prefix=\"where\" prefixOverrides=\"and | or\"&gt; &lt;if test=\"username != null and username != ''\"&gt; and username=#&#123;username&#125; &lt;/if&gt; &lt;if test=\"sex != null and sex != ''\"&gt; and sex = #&#123;sex&#125; &lt;/if&gt; &lt;/trim&gt;&lt;/select&gt; 属性prefix：前缀 prefixoverride：去掉第一个and或者是orsuffix：后缀 suffixoverride：去掉最后一个逗号（也可以是其他的标记，就像是上面前缀中的and一样） SQL片段有时候可能某个 sql 语句我们用的特别多，为了增加代码的重用性，简化代码，我们需要将这些代码抽取出来，然后使用时直接调用比如查询user表的判断,查询到结果的列名,代码示例:123456789101112131415161718192021&lt;!-- sql片段 --&gt;&lt;sql id=\"query_user_where\"&gt; &lt;if test=\"username != null and username != ''\"&gt; and username like '%$&#123;username&#125;%' &lt;/if&gt; &lt;if test=\"sex != null and sex != ''\"&gt; and sex=#&#123;sex&#125; &lt;/if&gt; &lt;if test=\"id != null and id != ''\"&gt; and id=#&#123;id&#125; &lt;/if&gt; &lt;if test=\"birthday != null and birthday != ''\"&gt; and birthday=#&#123;birthday&#125; &lt;/if&gt; &lt;if test=\"address != null and address != ''\"&gt; and address=#&#123;address&#125; &lt;/if&gt;&lt;/sql&gt;&lt;sql id=\"select_user_where\"&gt; id,username,birthday,sex,address&lt;/sql&gt; 引用SQL片段示例:12345678&lt;select id=\"findUsers\" parameterType=\"user\" resultType=\"user\"&gt; SELECT &lt;include refid=\"select_user_where\"/&gt; FROM t_user &lt;where&gt; &lt;include refid=\"query_user_where\"/&gt; &lt;/where&gt;&lt;/select&gt; 注意：最好基于 单表来定义sql片段，提高片段的可重用性,另外在sql 片段中不要包括where foreach语句如果我们需要批量删除用户的话,我们可以使用foreach语句来完成,代码示例:123456789&lt;!-- 批量删除 --&gt;&lt;delete id=\"batchDeleteUsers\" parameterType=\"usercustom\"&gt; DELETE FROM t_user &lt;where&gt; &lt;foreach collection=\"ids\" item=\"uid\" open=\"(\" close=\")\" separator=\"or\"&gt; id=#&#123;uid&#125; &lt;/foreach&gt; &lt;/where&gt;&lt;/delete&gt; 先贴上最终的sql语句1DELETE FROM t_user WHERE ( id=? or id=? or id=? ) 说明:parameterType定义的usercustom为我们自定义的一个类,用List来存储要删除的用户id,之后我们再使用foreach来批量删除属性:collection:指定输入对象中的集合属性item:集合中遍历的值open:开始遍历时拼接的字符串close:结束遍历时拼接的字符串separator:遍历对象中需要拼接的字符串 总结在编写动态SQL语句之前一定要写原生的sql语句出来,保证可运行,再通过mybatis动态sql照着改,降低出错率!","categories":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://www.perfree.top/categories/MyBatis/"}],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://www.perfree.top/tags/MyBatis/"}]},{"title":"MyBatis Mapper代理的开发方式","slug":"2018-06-12","date":"2018-06-12T10:07:07.000Z","updated":"2018-06-12T10:49:35.097Z","comments":true,"path":"2018/06/12/2018-06-12/","link":"","permalink":"http://www.perfree.top/2018/06/12/2018-06-12/","excerpt":"","text":"Mapper接口开发方法只需要程序员编写Mapper接口（相当于Dao接口），由Mybatis框架根据接口定义创建接口的动态代理对象，代理对象的方法体同上边Dao接口实现类方法。同时mybatis官方也推荐使用mapper代理方法开发mapper接口，程序员不用编写mapper接口实现类，使用mapper代理方法时，输入参数可以使用pojo包装对象或map对象，保证dao的通用性。 1.开发规范(1) Mapper.xml文件中的namespace与mapper接口的类路径相同。(2) Mapper接口方法名和Mapper.xml中定义的每个statement的id相同(3) Mapper接口方法的输入参数类型和mapper.xml中定义的每个sql 的parameterType的类型相同(4) Mapper接口方法的输出参数类型和mapper.xml中定义的每个sql的resultType的类型相同 2.Mapper.xml映射文件定义mapper映射文件UserMapper.xml,需要修改如下几项: (1) namespace的值为UserMapper接口的路径(2) parameterType要和接口定义的输入参数类型保持一致(3) resultType同样和接口中定义的输出(返回)参数类型保持一致,如果返回的值类型为List,直接定义为实体存储对象即可,这和selectOne或selectList有关 代码示例:123456789101112&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"com.fly.mapper.UserMapper\"&gt; &lt;select id=\"findUserById\" parameterType=\"int\" resultType=\"user\"&gt; SELECT * FROM t_user WHERE id = #&#123;id&#125; &lt;/select&gt; &lt;update id=\"updateUserById\" parameterType=\"user\"&gt; UPDATE t_user SET username = #&#123;username&#125; WHERE id = #&#123;id&#125; &lt;/update&gt;&lt;/mapper&gt; 3.Mapper.java接口文件接口的定义需注意以下几项: (1) Mapper接口方法名和Mapper.xml中定义的statement的id相同(2) Mapper接口方法的输入参数类型和mapper.xml中定义的statement的parameterType的类型相同(3) Mapper接口方法的输出参数类型和mapper.xml中定义的statement的resultType的类型相同 代码示例:12345678910package com.fly.mapper;import com.fly.pojo.User;public interface UserMapper &#123; //根据id查找用户信息 public User findUserById(int id); //根据id修改用户名称 public void updateUserById(User user);&#125; 4.加载Mapper.xml映射文件在sqlMapConfig.xml做如下修改(多种方式加载):12345678&lt;mappers&gt; &lt;!-- 通过mapper代理接口加载mapper配置文件mapper接口和映射文件名称相同，且在同一目录下面 --&gt; &lt;!-- &lt;mapper class=\"com.fly.mapper.UserMapper\"/&gt; --&gt; &lt;!-- 单个加载映射文件 --&gt; &lt;mapper resource=\"mapper/UserMapper.xml\"/&gt; &lt;!-- 批量加载映射文件 必须保证mapper配置文件mapper接口和映射文件名称相同且在同一目录下面 --&gt; &lt;!-- &lt;package name=\"com.fly.mapper\"/&gt; --&gt;&lt;/mappers&gt; 5.测试这里使用了junit进行测试: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package com.fly.test;import java.io.InputStream;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.Before;import org.junit.Test;import com.fly.mapper.UserMapper;import com.fly.pojo.User;public class MybatisTest &#123; private SqlSessionFactory ssf; @Before public void createSqlSessionFactory() throws Exception&#123; String resource = \"sqlMapConfig.xml\"; InputStream is = Resources.getResourceAsStream(resource); //使用SqlSessionFactoryBuilder创建sessionFactory SqlSessionFactoryBuilder ssfb = new SqlSessionFactoryBuilder(); ssf=ssfb.build(is); &#125; @Test public void findUserById()&#123; //获取session SqlSession session = ssf.openSession(); //创建usermapper对象，mybatis自动生成mapper代理对象 UserMapper mapper = session.getMapper(UserMapper.class); //调用代理对象方法 User u = mapper.findUserById(10); System.out.println(u); //关闭session session.close(); &#125; @Test public void updateUserById()&#123; //获取session SqlSession session = ssf.openSession(); //创建usermapper对象，mybatis自动生成mapper代理对象 UserMapper mapper = session.getMapper(UserMapper.class); User u = new User(); u.setId(10); u.setUsername(\"小钢炮\"); //调用代理对象方法 mapper.updateUserById(u); //提交 session.commit(); //关闭session session.close(); &#125;&#125; 6.总结(1) selectOne和selectList 如果mapper方法返回单个pojo对象（非集合对象），代理对象内部通过selectOne查询数据库。 如果mapper方法返回集合对象，代理对象内部通过selectList查询数据库。 (2) namespace (重申)Mapper.xml文件中的namespace与mapper接口的类路径一定要相同。 7.最后扩展下#{}和${}(1) #{} #{}表示一个占位符号，#{}接收输入参数，类型可以是简单类型，pojo、hashmap。 如果接收简单类型，#{}中可以写成value或其它名称。 #{}接收pojo对象值，通过OGNL读取对象中的属性值，通过属性.属性.属性...的方式获取对象属性值。 (2) ${} ${}表示一个拼接符号，会引用sql注入，所以不建议使用${} ${}接收输入参数，类型可以是简单类型，pojo、hashmap。 如果接收简单类型，${}中只能写成value。 ${}接收pojo对象值，通过OGNL读取对象中的属性值，通过属性.属性.属性…的方式获取对象属性值。","categories":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://www.perfree.top/categories/MyBatis/"}],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://www.perfree.top/tags/MyBatis/"}]},{"title":"初次配置使用MyBatis","slug":"2018-06-11","date":"2018-06-11T08:22:18.000Z","updated":"2018-06-13T12:14:36.606Z","comments":true,"path":"2018/06/11/2018-06-11/","link":"","permalink":"http://www.perfree.top/2018/06/11/2018-06-11/","excerpt":"","text":"MyBatis是一款支持定制化SQL,存储过程以及高级映射的优秀的持久层框架。MyBatis 避免了几乎所有的 JDBC 代码和手工设置参数以及抽取结果集。MyBatis 使用简单的 XML 或注解来配置和映射基本体，将接口和 Java 的 POJOs(Plain Old Java Objects,普通的 Java对象)映射成数据库中的记录。官方文档 1.下载MyBatis官方下载地址这里使用的是mybatis-3.4.6.zip 2.导包将下载的压缩包解压,导入里边所有jar包(一共13个…),之后再导入所使用的数据库jar包就ok了,这里使用的是MySql数据库 3.全局配置web项目在Java Resources新建config资源目录,在该目录下新建MyBatis全局配置文件sqlMapConfig.xml(名称随意),它包含了数据源和事务管理器等设置和属性信息,基础环境配置:12345678910111213141516171819202122232425&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE configurationPUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"\"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt; &lt;environments default=\"development\"&gt; &lt;environment id=\"development\"&gt; &lt;transactionManager type=\"JDBC\"/&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;!-- 数据库连接配置 --&gt; &lt;property name=\"driver\" value=\"$&#123;driver&#125;\"/&gt; &lt;property name=\"url\" value=\"$&#123;url&#125;\"/&gt; &lt;property name=\"username\" value=\"$&#123;username&#125;\"/&gt; &lt;property name=\"password\" value=\"$&#123;password&#125;\"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;environment id=\"development2\"&gt; &lt;!--核心映射文件地址,示例如下(可使用相对路径或者绝对路径)--&gt; &lt;mapper resource=\"mapper/UserMapper.xml\"/&gt; &lt;!--绝对路径--&gt; &lt;mapper url=\"file:///var/sqlmaps/AuthorMapper.xml\"/&gt; ...... &lt;/environment&gt; &lt;/environments&gt; &lt;/configuration&gt; 3.1.MyBatis 事务管理类JDBC - 这个类型直接全部使用 JDBC 的提交和回滚功能。它依靠使用连接的数据源来管理事务的作用域。MANAGED - 这个类型什么不做 ， 它从不提交 、 回滚和关闭连接 。 而是让窗口来管理事务的全部生命周期 。（比如说 Spring 或者JAVAEE 服务器） 3.2.MyBatis 数据源类型UNPOOLED -这个数据源实现只是在每次请求的时候简单的打开和关闭一个连接。虽然这有点慢，但作为一些不需要性能和立即响应简单应用来说 ，不失为一种好选择 。POOLED - 这个数据源缓存 JDBC 连接对象用于避免每次都要连接和生成连接实例而需要的验证时间 。对于并发WEB应用，这种方式非常流行因为它有最快的响应时间。JNDI - 这个数据源实现是为了准备和 Spring 或应用服务一起使用，可以在外部也可以在内部配置这个数据源，然后在JNDI上下文中引用它 4.log4j在config目录下新建log4j.properties复制下方代码:123456# Global logging configurationlog4j.rootLogger=DEBUG, stdout# Console output...log4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern=%5p [%t] - %m%n 5.核心映射文件在config下新建mapper包,在包内新建UserMapper.xml(名称随意..)参考以下代码:123456789101112&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//ibatis.apache.org//DTD Mapper 3.0//EN\" \"http://ibatis.apache.org/dtd/ibatis-3-mapper.dtd\"&gt; &lt;mapper namespace=\"user\" &gt; &lt;select id =\"getUsers\" resultType=\"com.entiy.User\"&gt; SELECT * FROM USER &lt;/select&gt; &lt;select id=\"findUserById\" parameterType=\"int\" resultType=\"com.test.User\"&gt; SELECT * FROM USER WHERE id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; 5.1.SQL 映射文件结构：注:第一次使用仅作为了解就可以了cache - 配置给定命名空间的缓存。cache-ref – 从其他命名空间引用缓存配置。resultMap – 最复杂，也是最有力量的元素，用来描述如何从数据库结果集中来加载对象。 sql – 可以重用的 SQL 块，也可以被其他语句引用。insert – 映射插入语句update – 映射更新语句delete – 映射删除语句select – 映射查询语句 6.Java代码这里直接在main方法中写的:12345678910111213141516171819202122232425262728293031323334353637383940package com.fly;import java.io.InputStream;import java.util.List;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import com.entiy.User;public class Test &#123; public static void main(String[] args) &#123; SqlSession session = null; //声明配置文件 String resource = \"sqlMapConfig.xml\"; try &#123; //读取全局配置文件 InputStream is = Resources.getResourceAsStream(resource); //创建SqlSessionFactory会话工厂 SqlSessionFactoryBuilder ssfb = new SqlSessionFactoryBuilder(); SqlSessionFactory ssf = ssfb.build(is); //获取SqlSession会话 session = ssf.openSession(); //拿到结果集放入List集合 List&lt;User&gt; list = session.selectList(\"user.getUsers\"); //遍历输出 for(User u:list)&#123; System.out.println(u.toString()); &#125; &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125;finally&#123; //关闭资源 if(session != null)&#123; session.close(); &#125; &#125; &#125;&#125; 6.1.SqlSessionFactoryBuilder的生命周期：这个类可以被初始 、 使用和丢弃 ， 如果你已经创建好了一个 SqlSessionFactory 后就不用再保留它 。 因此 ，SqlSessionFactoryBuilder 的最好作用域是方法体内，比如说定义一个方法变量。你可以重复使 用SqlSessionFactoryBuilder 生成多个SqlSessionFactory 实例 ， 但是最好不要强行保留 ， 因为 XML 的解析资源要用来做其它更重要的事。 6.2.SqlSessionFactory：一旦创建， SqlSessionFactory 就会在整个应用过程中始终存在。所以没有理由去销毁和再创建它，一个应用运行中也不建议多次创建 SqlSessionFactory 。 如果真的那样做 ， 会显得很拙劣 。 因此 SqlSessionFactor y最好的作用域是 Application 。可以有多种方法实现。最简单的方法是单例模式或者是静态单例模式 。 然而这既不是广泛赞成和好用的 。 反而 ， 使用 Google Guice 或 Spring 来进行依赖反射会更好 。 这些框架允许你生成管理器来管理 SqlSessionFactory 的单例生命周期。 6.3.SqlSession：每个线程都有自己的 SqlSession 实例， SqlSession 实例是不能被共享，也是不是线程安全的。因此最好使用 Request 作用域或者方法体作用域。不要使用类的静态变量来引用一个 SqlSession 实例，甚至不要使用类的一个实例变更来引用。如果你正在使用 WEB 框架，应该让 SqlSession 跟随 HTTP 请求的相似作用域。也就是说，在收到一个 HTTP 请求过后，打开 SqlSession ，等返回一个回应以后，立马关掉这个 SqlSession 。 关闭 SqlSession 是非常重要的。你必须要确保 SqlSession 在 finally 方法体中正常关闭","categories":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://www.perfree.top/categories/MyBatis/"}],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://www.perfree.top/tags/MyBatis/"}]},{"title":"第一篇博客","slug":"hello-world","date":"2018-05-10T10:07:07.000Z","updated":"2018-06-13T09:15:22.747Z","comments":true,"path":"2018/05/10/hello-world/","link":"","permalink":"http://www.perfree.top/2018/05/10/hello-world/","excerpt":"","text":"第一次使用 Hexo来搭建个人博客! 还是蛮兴奋的^_^… 下面的信息就作为一个入门的备份吧: hexo官方文档 故障排除 Hexo/GitHub. 快速开始创建一个新帖子1$ hexo new \"My New Post\" 更多信息: 写作 运行服务器1$ hexo server 更多信息: 服务器 生成静态文件(网页)1$ hexo generate 更多信息: 生成 部署到远程站点1$ hexo deploy 更多信息: 部署","categories":[{"name":"其他","slug":"其他","permalink":"http://www.perfree.top/categories/其他/"}],"tags":[{"name":"其他","slug":"其他","permalink":"http://www.perfree.top/tags/其他/"}]}]}